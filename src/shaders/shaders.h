#ifndef SHADERS_H
#define SHADERS_H

#include <string>
#include <map>

std::map<std::string, std::string> shader_sources = {
{"fragment", "#version 330\n\nsmooth in vec3 theColor;\nsmooth in vec4 theNormal;\nsmooth in vec4 thePosition;\n\nuniform vec4 camera;\n\nconst float specular = .2;\nconst float diffuse = .3;\nconst float ambient = .5;\n\nconst float shine = 1;\nconst float surfaceSpec = 1;\nconst float surfaceDiff = 1;\nconst float surfaceAmb = 1;\n\nlayout(location = 0) out vec3 color;\n\n\n///*\nfloat dot(vec4 v, vec4 w) {\n	return v.x*w.x + v.y*w.y + v.z*w.z - v.w*w.w;\n}\n\nfloat length(vec4 v) {\n	return sqrt(dot(v,v));\n}\n\nvec4 normalize(vec4 v) {\n	return v / length(v);\n}\n\nfloat angle(vec4 v, vec4 w) {\n	return acos(dot(normalize(v),normalize(w)));\n}\n\nfloat dist(vec4 p1, vec4 p2) {\n	return acosh(-dot(p1,p2));\n}\n\nvec4 expinv(vec4 basepoint, vec4 target) {\n	float r = dist(basepoint, target);\n	if(r==0) {\n		return vec4(0,0,0,0);\n	}\n	vec4 u = target - cosh(r)*basepoint;\n	return (r/sinh(r))*u;\n}\n//*/\nvoid main() {\n	//color = theColor;\n	///*\n	\n	float intensity;\n	\n	vec4 norm = normalize(theNormal);\n	vec4 lampPos = vec4(0, 10.0179, 0, 10.0677);\n	vec4 lamp = expinv(thePosition, lampPos);\n	vec4 lampNorm = normalize(lamp);\n	\n	vec4 optimal = 2*(dot(norm,lampNorm)*norm)-lampNorm;\n	\n	intensity = surfaceAmb*ambient + surfaceDiff*(dot(lamp,theNormal))*diffuse + surfaceSpec*pow((dot(optimal,camera)),shine)*specular;\n	color = intensity*theColor;\n	//*/\n}"},
{"fragment_offset", "#version 330\n\nsmooth in vec3 theColor;\nuniform vec3 theOffset;\n\nlayout(location = 0) out vec3 color;\n\nvoid main() {\n    color = clamp(theColor + theOffset, 0.0, 1.0);\n}\n"},
{"rift_fragment", "#version 330 core\n \nin vec2 theUV; //TODO: rename this\n\nout vec4 color;\n \nuniform sampler2D the_texture;\nuniform float aspect_ratio;\nuniform vec2 lens_center; // in the range [-1,1]x[-1,1]\nuniform vec4 distortion_params = vec4(1, 0.22, 0.24, 0);\n\nconst float PI = 3.1415926535;\n\n// Convert from the uv coordinates in [0,1]x[0,1] to a more\n// convenient coordinate system for distortion, where the lens_center\n// corresponds to (0,0) and the x- and y-scales are the same\nvec2 to_oculus_coordinates(vec2 p) {\n\n    // from [0,1]x[0,1] to [-1,1]x[-1,1]\n    p = vec2(-1.0, -1.0) + 2*p;\n\n    // subtract lens center\n    p = p - lens_center;\n\n    // make x- and y-scales the same\n    p.y = p.y / aspect_ratio;\n\n    return p;\n}\n\nvec2 from_oculus_coordinates(vec2 p) {\n    p.y = p.y * aspect_ratio;\n    p = p + lens_center;\n    p = vec2(0.5, 0.5) + 0.5*p;\n    return p;\n}\n\nvec2 distort(vec2 p) {\n    float r_squared = p.x * p.x + p.y * p.y;\n    float factor = distortion_params[0] +\n                   distortion_params[1] * r_squared +\n                   distortion_params[2] * r_squared * r_squared +\n                   distortion_params[3] * r_squared * r_squared * r_squared;\n    return p * factor / 1.4;\n}\n\nvoid main() {\n    vec2 new_uv = from_oculus_coordinates(distort(to_oculus_coordinates(theUV)));\n    color = texture(the_texture, new_uv);\n}\n\n"},
{"rift_vertex", "#version 330 core\n\nlayout(location = 0) in vec2 position;\nlayout(location = 1) in vec2 uv;\n\nout vec2 theUV;\n\nvoid main(){\n  gl_Position = vec4(position, 0, 1);\n  theUV = uv;\n}\n"},
{"vertex", "#version 330\n\nlayout (location = 0) in vec4 position;\nlayout (location = 1) in vec3 color;\nlayout (location = 2) in vec4 normal;\n\nuniform mat4 projection;\nuniform mat4 modelview;\n\nsmooth out vec3 theColor;\nsmooth out vec4 theNormal;\nsmooth out vec4 thePosition;\n\nvoid main()\n{\n    gl_Position = (projection * modelview * position);\n	thePosition = gl_Position;\n    theColor = color;\n	theNormal = normal;\n}\n"},
};

#endif
